# U1T3 - Desafio de ImplementaÃ§Ã£o

Atividade realizada por:
- **Aluno**: [Carlos Gabriel Medeiros da Silva](https://github.com/CarlosG18) **matricula**: 20230093859
- **Aluno**: [Jean Magnus Araujo de Souza Junior](https://github.com/JeanMagnus) **matricula**: 20240001171

## [1/5] ğŸ¤” Definindo os problemas

Os problemas resolvidos sÃ£o fornecidos pelo [repositorio do professor Ivanovitch](https://github.com/ivanovitchm/datastructure) referentes ao assunto da **semana 4**.


### ğŸ“Œ Problema 1

- **definiÃ§Ã£o:** Dado um valor ( k ) e uma Ã¡rvore de busca binÃ¡ria (BST) nÃ£o vazia com valores distintos, encontre o valor mais prÃ³ximo de ( k ) na BST.

- **exemplo:**
<center>
    <img width=300 src="../U1T3/imgs/problema1.jpg">
</center>

- **input**: k = 43 -> **output**: 45

- **aplicaÃ§Ã£o desse problema:** Esse problema pode ser Ãºtil em sistemas de busca, como em um sistema de busca de produtos online. Por exemplo, um usuÃ¡rio pode inserir um preÃ§o desejado e o sistema pode usar a Ã¡rvore de busca binÃ¡ria para encontrar produtos com preÃ§os mais prÃ³ximos ao valor especificado pelo usuÃ¡rio, mesmo que nÃ£o haja um produto com o preÃ§o exato. Isso pode melhorar a experiÃªncia do usuÃ¡rio ao permitir que ele encontre produtos que atendam Ã s suas necessidades, mesmo que nÃ£o tenham preÃ§os exatos correspondentes.

***

### ğŸ“Œ Problema 2

- **definiÃ§Ã£o:** Dada uma Ã¡rvore de busca binÃ¡ria (BST) nÃ£o vazia, retorne o ( k )Âº maior elemento da BST, onde ( k ) Ã© uma variÃ¡vel inteira fornecida.

- **exemplo:**
<center>
    <img width=300 src="../U1T3/imgs/problema2.jpg">
</center>

- **input**: k = 6 -> **output**: 28

- **aplicaÃ§Ã£o desse problema:** Esse problema pode ser Ãºtil em situaÃ§Ãµes onde Ã© necessÃ¡rio encontrar valores especÃ­ficos em uma coleÃ§Ã£o ordenada, como em sistemas de anÃ¡lise de dados para encontrar percentis especÃ­ficos em conjuntos de dados. Por exemplo, em um sistema de anÃ¡lise de vendas, pode-se usar esse algoritmo para encontrar o produto que estÃ¡ no ( k )Âº lugar em termos de vendas, ajudando a identificar os produtos mais populares.

## [2/5] ğŸ’¡ SoluÃ§Ãµes

### ğŸ“Œ Problema 1

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_01_closestvalue.ipynb) - notebook com o primeiro desafio.

explicar como foi feito a soluÃ§Ã£o

---

### ğŸ“Œ Problema 2

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_02_kth_largest.ipynb) - notebook com o segundo desafio.

Para realizar a soluÃ§Ã£o do problema 2, foi ultizado duas funÃ§Ãµes auxiliares. a primeira delas Ã© a `size_tree()`que Ã© responsavel por calcular de forma recursiva a quantidade de nÃ³s filhos dado um nÃ³ pai passado como argumento:

```python
def size_tree(node):
    """
        funÃ§Ã£o responsavel por calcular a quantidade de nos filhos dado um nÃ³ pai.

        argumentos:
            - node: nÃ³ pai que se deseja saber calcular quantos nÃ³s filhos possui

        retorno:
            - size: quantidade de nÃ³s filhos que o nÃ³ (node) possui
    """
    if node is None:
       return 0

    left_count  = size_tree(node.left_child) if node.left_child else 0
    right_count  = size_tree(node.right_child) if node.right_child else 0

    return 1 + left_count + right_count
```

A funÃ§Ã£o que de fato resolve o problema 2 Ã© a funÃ§Ã£o `findKthLargestValue()` mostrada a seguir:

```python
def findKthLargestValue(tree, k):
    """
    Finds the kth largest integer in a Binary Search Tree (BST).

    The function traverses the BST in an in-order manner to collect the node values in a sorted list.
    It then returns the kth largest value from this list. The BST is assumed to contain only integer values.
    In case of duplicate integers, they are treated as distinct values.
    The kth largest integer is determined in the context of these distinct values.

    Parameters:
    tree (BST): the Binary Search Tree (BST).
    k (int): A positive integer representing the kth position.

    Returns:
    int: The kth largest integer present in the BST.
    """
    vector = []
    index_aux = k
    
    if tree.root.right_child is not None:
        qtd_right_tree = size_tree(tree.root.right_child)
    else: 
        qtd_right_tree = 0
    
    if k > qtd_right_tree:
        index_aux -= qtd_right_tree
        if index_aux == 1:
            return tree.root.value
        else:
            index_aux -= 1
            _, vector = search_element(vector, tree.root.left_child, index_aux)
    else:
        _, vector = search_element(vector, tree.root.right_child, index_aux)

    return vector[0]
```

**vamos entender melhor como ela funciona? Simboraaa!:**

A soluÃ§Ã£o se baseia na principal caracterÃ­stica de uma **BST**, que Ã© possuir os maiores valores para a direita dos nÃ³s. com isso em mente, temos as seguintes etapas:

- Primeiro definimos um vetor vazio, que serÃ¡ usado para preencher com o valor adequado:

```python
vector = []
```

- obtemos a quantidade de elementos Ã¡ direita do nÃ³ raiz da nossa bst usando a `size_tree()` anteriormente abordada aplicando a seguinte lÃ³gica:

```python
if tree.root.right_child is not None:
        qtd_right_tree = size_tree(tree.root.right_child)
    else: 
        qtd_right_tree = 0
```

> Mas porque precisamos saber o tamanho da sub-Ã¡rvore direita do nÃ³ raiz?

Nessa soluÃ§Ã£o, para definirmos se vamos seguir a busca pela esquerda ou direita do nÃ³ raiz da Ã¡rvore, precisamos comparar o valor do argumento `k` com o tamanho da sub-Ã¡rvore direita, como vemos a seguir:

```python
index_aux = k
        
if k > qtd_right_tree:
    index_aux -= qtd_right_tree
    if index_aux == 1:
        return tree.root.value
    else:
        index_aux -= 1
        _, vector = search_element(vector, tree.root.left_child, index_aux)
else:
    _, vector = search_element(vector, tree.root.right_child, index_aux)
```

Basicamente seguimos a seguinte lÃ³gica:

- comparamos o valor `k` com o valor da sub-arvore direita `qtd_right_tree`;
- caso o valor de `k` for maior que `qtd_right_tree`, isso indica que o valor correto estÃ¡ do lado esquerdo da nossa BST e por isso nÃ£o precisamos percorrer o lado direito. caso contrÃ¡rio, o valor correto estÃ¡ no lado direito e discartamos o lados esquerdo da nossa Ã¡rvore.
- perceba que precisamos fazer um desconto na variavel `k`, caso o valor de `k` for maior que a variavel `qtd_right_tree`, aplicando a diferenÃ§a em uma nova variavel `index_aux`. Esse desconto Ã© feito para saber qual "index" estÃ¡ o valor correto.
- com isso chamamos a funÃ§Ã£o `search_element()` para de fato encontrar o valor desejado.

A funÃ§Ã£o `search_element()`, definida logo abaixo, foi ultilizada para percorrer a sub-Ã¡rvore definida e adicionar o valor correto ao vetor `vector`: 

```python
def search_element(vector, node, index_aux):
    """
        funÃ§Ã£o que obtem um vetor com o nÃ³ desejado

        argumentos:
            - vector: vetor que armazenarÃ¡ o valor correto
            - node: nÃ³ pai que comeÃ§arÃ¡ a adiÃ§Ã£o
            - index_aux: variavel de auxilio para encontrar o valor correto

        retorno:
            - index_aux: variavel de auxilio para encontrar o valor correto
            - vector: vetor com o valor correto
    """
    if node.right_child is not None:
        index_aux, vector = search_element(vector, node.right_child,index_aux)

    index_aux -= 1
    if index_aux == 0:
        vector.append(node.value)
    
    if node.left_child is not None:
        index_aux, vector = search_element(vector, node.left_child, index_aux)

    return index_aux, vector

```

basicamente essa funÃ§Ã£o recursiva, os primeiros elementos visitados sÃ£o os elementos da direita (maiores). a cada visita, a variavel `index_aux` Ã© decrementada, e apÃ³s isso, Ã© feita a verificaÃ§Ã£o onde se o valor de `index_aux` for igual a zero, o valor do nÃ³ atual deverÃ¡ ser adicionado no vetor `vector`. isso garante que o vetor seja preenchido apenas com um valor e com o valor correto. 

- obtemos o valor resposta aplicando a seguinte expressÃ£o:

```python
return vector[0]
```

> NÃ£o ficou claro o bastante? veja esse gif que ilustra a funÃ§Ã£o de uma forma mais "compacta"

<center>
    <img src="../U1T3/imgs/gif_q2.gif">
</center>

## [3/5] ğŸ§ª Como executar os codigos e testes

Tanto o notebook referente ao problema 1 quanto o problema 2 possuem testes para garantir que as funÃ§Ãµes desenvolvidas funcionem adequadamente. 

**para rodar os testes diretamente do notebook:**

```bash
!pytest closestvalue.py -vv
```

**caso vocÃª queira rodar em seu ambiente de desenvolvimento**:

- crie o arquivo que conterÃ¡ os testes (lembrando que as funÃ§Ãµes de teste devem comeÃ§ar com a palavra `test`);

- execute o comando:

```bash
$ pytest <nomedoarquivo>.py
```

## [4/5] âŒ› AnÃ¡lise da complexidade dos problemas

### ğŸ“Œ Problema 1:

---

### ğŸ“Œ Problema 2:

## [5/5] ğŸ¥ Video Explicativo

- ğŸ¥ [Link do video](https://drive.google.com/file/d/14LrgX_7vX5yoe7F-W9U4S-vjGLZN6J7S/view?usp=sharing)
