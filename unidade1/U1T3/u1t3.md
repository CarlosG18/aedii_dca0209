# U1T3 - Desafio de Implementa√ß√£o

Atividade realizada por:
- **Aluno**: [Carlos Gabriel Medeiros da Silva](https://github.com/CarlosG18) **matricula**: 20230093859
- **Aluno**: [Jean Magnus Araujo de Souza Junior](https://github.com/JeanMagnus) **matricula**: 20240001171

## [1/5] ü§î Definindo os problemas

Os problemas resolvidos s√£o fornecidos pelo [repositorio do professor Ivanovitch](https://github.com/ivanovitchm/datastructure) referentes ao assunto da **semana 4**.


### üìå Problema 1

- **defini√ß√£o:** Dado um valor ( k ) e uma √°rvore de busca bin√°ria (BST) n√£o vazia com valores distintos, encontre o valor mais pr√≥ximo de ( k ) na BST.

- **exemplo:**

<center>
    <img width=300 src="../U1T3/imgs/problema1.jpg"/>
</center>

- **input**: k = 43 -> **output**: 45

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em sistemas de busca, como em um sistema de busca de produtos online. Por exemplo, um usu√°rio pode inserir um pre√ßo desejado e o sistema pode usar a √°rvore de busca bin√°ria para encontrar produtos com pre√ßos mais pr√≥ximos ao valor especificado pelo usu√°rio, mesmo que n√£o haja um produto com o pre√ßo exato. Isso pode melhorar a experi√™ncia do usu√°rio ao permitir que ele encontre produtos que atendam √†s suas necessidades, mesmo que n√£o tenham pre√ßos exatos correspondentes.

***

### üìå Problema 2

- **defini√ß√£o:** Dada uma √°rvore de busca bin√°ria (BST) n√£o vazia, retorne o ( k )¬∫ maior elemento da BST, onde ( k ) √© uma vari√°vel inteira fornecida.

- **exemplo:**
<center>
    <img width=300 src="../U1T3/imgs/problema2.jpg"/>
</center>

- **input**: k = 6 -> **output**: 28

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em situa√ß√µes onde √© necess√°rio encontrar valores espec√≠ficos em uma cole√ß√£o ordenada, como em sistemas de an√°lise de dados para encontrar percentis espec√≠ficos em conjuntos de dados. Por exemplo, em um sistema de an√°lise de vendas, pode-se usar esse algoritmo para encontrar o produto que est√° no ( k )¬∫ lugar em termos de vendas, ajudando a identificar os produtos mais populares.

## [2/5] üí° Solu√ß√µes

### üìå Problema 1

Para a resolu√ß√£o desse problema, foi criado uma fun√ß√£o chamada `findClosestValue()`, que recebe uma √°rvore BST e um valor que deseja ser encontrado, ou um valor pr√≥ximo a ele, nessa √°rvore. Ent√£o para o desenvolvimento da fun√ß√£o, primeiramente foi criada uma vari√°vel que armazenar√° o valor atual mais pr√≥ximo do valor desejado, inicialmente nulo. Ent√£o, foi criada uma fun√ß√£o para atravessar a √°rvore, recursivamente, a fim de encontrar este valor desejado. Dessa forma, a fun√ß√£o analisa n√≥ por n√≥, se houver um valor mais pr√≥ximo que o valor almejado ele ser√° armazenado na variavel 'closest_value' declarada acima. Tudo isso √© analisado com base na propriedade da BST.

Segue abaixo a fun√ß√£o criada:

```python
def findClosestValue(tree, target):
    # Iniciando a vari√°vel como nula
    closest_value = None

    # Fun√ß√£o auxiliar para percorrer recursivamente
    def traverse(node):
        nonlocal closest_value

        # Caso base: se o n√≥ atual analisado for nulo, retorne a fun√ß√£o imediatamente
        if node is None:
            return

        # Atualiza o valor mais pr√≥ximo (na vari√°vel) caso seja necess√°rio
        if closest_value is None or abs(node.value - target) < abs(closest_value - target):
            closest_value = node.value

        # Continua a busca atravessando a √°rvore com base nas propriedades da BST
        if target < node.value:
            traverse(node.left_child)
        elif target > node.value:
            traverse(node.right_child)

    # Inicia a busca/travessia a partir do n√≥ raiz da √°rvore
    traverse(tree.root)

    return closest_value
```

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_01_closestvalue.ipynb) - notebook com o primeiro desafio.
-  [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/solution_01.ipynb) - notebook com a solu√ß√£o e testes.

### üìå Problema 2

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_02_kth_largest.ipynb) - notebook com o segundo desafio.

Para realizar a solu√ß√£o do problema 2, foi ultizado duas fun√ß√µes auxiliares. a primeira delas √© a `size_tree()`que √© responsavel por calcular de forma recursiva a quantidade de n√≥s filhos dado um n√≥ pai passado como argumento:

```python
def size_tree(node):
    """
        fun√ß√£o responsavel por calcular a quantidade de nos filhos dado um n√≥ pai.

        argumentos:
            - node: n√≥ pai que se deseja saber calcular quantos n√≥s filhos possui

        retorno:
            - size: quantidade de n√≥s filhos que o n√≥ (node) possui
    """
    if node is None:
       return 0

    left_count  = size_tree(node.left_child) if node.left_child else 0
    right_count  = size_tree(node.right_child) if node.right_child else 0

    return 1 + left_count + right_count
```

A fun√ß√£o que de fato resolve o problema 2 √© a fun√ß√£o `findKthLargestValue()` mostrada a seguir:

```python
def findKthLargestValue(tree, k):
    """
    Finds the kth largest integer in a Binary Search Tree (BST).

    The function traverses the BST in an in-order manner to collect the node values in a sorted list.
    It then returns the kth largest value from this list. The BST is assumed to contain only integer values.
    In case of duplicate integers, they are treated as distinct values.
    The kth largest integer is determined in the context of these distinct values.

    Parameters:
    tree (BST): the Binary Search Tree (BST).
    k (int): A positive integer representing the kth position.

    Returns:
    int: The kth largest integer present in the BST.
    """
    vector = []
    index_aux = k
    
    if tree.root.right_child is not None:
        qtd_right_tree = size_tree(tree.root.right_child)
    else: 
        qtd_right_tree = 0
    
    if k > qtd_right_tree:
        index_aux -= qtd_right_tree
        if index_aux == 1:
            return tree.root.value
        else:
            index_aux -= 1
            _, vector = search_element(vector, tree.root.left_child, index_aux)
    else:
        _, vector = search_element(vector, tree.root.right_child, index_aux)

    return vector[0]
```

**vamos entender melhor como ela funciona? Simboraaa!:**

A solu√ß√£o se baseia na principal caracter√≠stica de uma **BST**, que √© possuir os maiores valores para a direita dos n√≥s. com isso em mente, temos as seguintes etapas:

- Primeiro definimos um vetor vazio, que ser√° usado para preencher com o valor adequado:

```python
vector = []
```

- obtemos a quantidade de elementos √° direita do n√≥ raiz da nossa bst usando a `size_tree()` anteriormente abordada aplicando a seguinte l√≥gica:

```python
if tree.root.right_child is not None:
        qtd_right_tree = size_tree(tree.root.right_child)
    else: 
        qtd_right_tree = 0
```

> Mas porque precisamos saber o tamanho da sub-√°rvore direita do n√≥ raiz?

Nessa solu√ß√£o, para definirmos se vamos seguir a busca pela esquerda ou direita do n√≥ raiz da √°rvore, precisamos comparar o valor do argumento `k` com o tamanho da sub-√°rvore direita, como vemos a seguir:

```python
index_aux = k
        
if k > qtd_right_tree:
    index_aux -= qtd_right_tree
    if index_aux == 1:
        return tree.root.value
    else:
        index_aux -= 1
        _, vector = search_element(vector, tree.root.left_child, index_aux)
else:
    _, vector = search_element(vector, tree.root.right_child, index_aux)
```

Basicamente seguimos a seguinte l√≥gica:

- comparamos o valor `k` com o valor da sub-arvore direita `qtd_right_tree`;
- caso o valor de `k` for maior que `qtd_right_tree`, isso indica que o valor correto est√° do lado esquerdo da nossa BST e por isso n√£o precisamos percorrer o lado direito. caso contr√°rio, o valor correto est√° no lado direito e discartamos o lados esquerdo da nossa √°rvore.
- perceba que precisamos fazer um desconto na variavel `k`, caso o valor de `k` for maior que a variavel `qtd_right_tree`, aplicando a diferen√ßa em uma nova variavel `index_aux`. Esse desconto √© feito para saber qual "index" est√° o valor correto.
- com isso chamamos a fun√ß√£o `search_element()` para de fato encontrar o valor desejado.

A fun√ß√£o `search_element()`, definida logo abaixo, foi ultilizada para percorrer a sub-√°rvore definida e adicionar o valor correto ao vetor `vector`: 

```python
def search_element(vector, node, index_aux):
    """
        fun√ß√£o que obtem um vetor com o n√≥ desejado

        argumentos:
            - vector: vetor que armazenar√° o valor correto
            - node: n√≥ pai que come√ßar√° a adi√ß√£o
            - index_aux: variavel de auxilio para encontrar o valor correto

        retorno:
            - index_aux: variavel de auxilio para encontrar o valor correto
            - vector: vetor com o valor correto
    """
    if node.right_child is not None:
        index_aux, vector = search_element(vector, node.right_child,index_aux)

    index_aux -= 1
    if index_aux == 0:
        vector.append(node.value)
    
    if node.left_child is not None:
        index_aux, vector = search_element(vector, node.left_child, index_aux)

    return index_aux, vector

```

basicamente essa fun√ß√£o recursiva, os primeiros elementos visitados s√£o os elementos da direita (maiores). a cada visita, a variavel `index_aux` √© decrementada, e ap√≥s isso, √© feita a verifica√ß√£o onde se o valor de `index_aux` for igual a zero, o valor do n√≥ atual dever√° ser adicionado no vetor `vector`. isso garante que o vetor seja preenchido apenas com um valor e com o valor correto. 

- obtemos o valor resposta aplicando a seguinte express√£o:

```python
return vector[0]
```

> N√£o ficou claro o bastante? veja esse gif que ilustra a fun√ß√£o de uma forma mais "compacta"

<center>
    <img src="../U1T3/imgs/gif_q2.gif"/>
</center>

## [3/5] üß™ Como executar os codigos e testes

Tanto o notebook referente ao problema 1 quanto o problema 2 possuem testes para garantir que as fun√ß√µes desenvolvidas funcionem adequadamente. 

**para rodar os testes diretamente do notebook:**

```bash
!pytest closestvalue.py -vv
```

**caso voc√™ queira rodar em seu ambiente de desenvolvimento**:

- crie o arquivo que conter√° os testes (lembrando que as fun√ß√µes de teste devem come√ßar com a palavra `test`);

- execute o comando:

```bash
$ pytest <nomedoarquivo>.py
```

## [4/5] ‚åõ An√°lise da complexidade dos problemas

### üìå Problema 1:
Ap√≥s analisar o funcionamento da fun√ß√£o encontrada para a solu√ß√£o do problema, percebemos que a complexidade da fun√ß√£o `findClosestValue()` depende do tamanho da √°rvore de busca bin√°ria e da profundidade do n√≥ mais pr√≥ximo ao valor alvo.

Em m√©dia, a complexidade de tempo √© O(log(N)), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre porque, em m√©dia, a busca em uma √°rvore de busca bin√°ria √© logar√≠tmica em rela√ß√£o ao n√∫mero de elementos na √°rvore. No entanto, no pior caso, a complexidade de tempo pode ser O(N), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre quando a √°rvore est√° desbalanceada e a busca percorre todos os n√≥s da √°rvore.

A complexidade de espa√ßo √© O(1), pois n√£o s√£o utilizadas estruturas de dados adicionais que dependem do tamanho da entrada.

- ü§î Dito isso, chegamos a um questionamento: quais s√£o as vantagens e desvantagens de resolver esse problema de forma iterativa em vez de recursivamente? 

Podemos responder esse questionamento analisando o funcionamento, e resumidamente, a abordagem iterativa oferece efici√™ncia de espa√ßo, controle direto sobre o fluxo de execu√ß√£o e evita o risco de estouro de pilha, mas pode ser mais complexa em alguns casos e menos expressiva em compara√ß√£o com a recursiva. 

---

### üìå Problema 2:

## [5/5] üé• Video Explicativo

- üé• [Link do video](https://drive.google.com/file/d/14LrgX_7vX5yoe7F-W9U4S-vjGLZN6J7S/view?usp=sharing)
