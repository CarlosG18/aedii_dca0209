# U1T3 - Desafio de Implementa√ß√£o

Atividade realizada por:
- **Aluno**: [Carlos Gabriel Medeiros da Silva](https://github.com/CarlosG18) **matricula**: 20230093859
- **Aluno**: [Jean Magnus Araujo de Souza Junior](https://github.com/JeanMagnus) **matricula**: 20240001171

## [1/5] ü§î Definindo os problemas

Os problemas resolvidos s√£o fornecidos pelo [repositorio do professor Ivanovitch](https://github.com/ivanovitchm/datastructure) referentes ao assunto da **semana 4**.


### üìå Problema 1

- **defini√ß√£o:** Dado um valor ( k ) e uma √°rvore de busca bin√°ria (BST) n√£o vazia com valores distintos, encontre o valor mais pr√≥ximo de ( k ) na BST.

- **exemplo:**

<p align="center">
    <img width=300 src="../U1T3/imgs/problema1.jpg"/>
</p>

- **input**: k = 43 -> **output**: 45

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em sistemas de busca, como em um sistema de busca de produtos online. Por exemplo, um usu√°rio pode inserir um pre√ßo desejado e o sistema pode usar a √°rvore de busca bin√°ria para encontrar produtos com pre√ßos mais pr√≥ximos ao valor especificado pelo usu√°rio, mesmo que n√£o haja um produto com o pre√ßo exato. Isso pode melhorar a experi√™ncia do usu√°rio ao permitir que ele encontre produtos que atendam √†s suas necessidades, mesmo que n√£o tenham pre√ßos exatos correspondentes.

***

### üìå Problema 2

- **defini√ß√£o:** Dada uma √°rvore de busca bin√°ria (BST) n√£o vazia, retorne o ( k )¬∫ maior elemento da BST, onde ( k ) √© uma vari√°vel inteira fornecida.

- **exemplo:**
<p align="center">
    <img width=300 src="../U1T3/imgs/problema2.jpg"/>
</p>

- **input**: k = 6 -> **output**: 28

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em situa√ß√µes onde √© necess√°rio encontrar valores espec√≠ficos em uma cole√ß√£o ordenada, como em sistemas de an√°lise de dados para encontrar percentis espec√≠ficos em conjuntos de dados. Por exemplo, em um sistema de an√°lise de vendas, pode-se usar esse algoritmo para encontrar o produto que est√° no ( k )¬∫ lugar em termos de vendas, ajudando a identificar os produtos mais populares.

## [2/5] üí° Solu√ß√µes

### üìå Problema 1

Para a resolu√ß√£o desse problema, foi criado uma fun√ß√£o chamada `findClosestValue()`, que recebe uma √°rvore BST e um valor que deseja ser encontrado, ou um valor pr√≥ximo a ele, nessa √°rvore. Ent√£o para o desenvolvimento da fun√ß√£o, primeiramente foi criada uma vari√°vel que armazenar√° o valor atual mais pr√≥ximo do valor desejado, inicialmente nulo. Ent√£o, foi criada uma fun√ß√£o para atravessar a √°rvore, recursivamente, a fim de encontrar este valor desejado. Dessa forma, a fun√ß√£o analisa n√≥ por n√≥, se houver um valor mais pr√≥ximo que o valor almejado ele ser√° armazenado na vari√°vel 'closest_value' declarada acima. Tudo isso √© analisado com base na propriedade da BST.

Segue abaixo a fun√ß√£o criada:

```python
def findClosestValue(tree, target):
    # Iniciando a vari√°vel como nula
    closest_value = None

    # Fun√ß√£o auxiliar para percorrer recursivamente
    def traverse(node):
        nonlocal closest_value

        # Caso base: se o n√≥ atual analisado for nulo, retorne a fun√ß√£o imediatamente
        if node is None:
            return

        # Atualiza o valor mais pr√≥ximo (na vari√°vel) caso seja necess√°rio
        if closest_value is None or abs(node.value - target) < abs(closest_value - target):
            closest_value = node.value

        # Continua a busca atravessando a √°rvore com base nas propriedades da BST
        if target < node.value:
            traverse(node.left_child)
        elif target > node.value:
            traverse(node.right_child)

    # Inicia a busca/travessia a partir do n√≥ raiz da √°rvore
    traverse(tree.root)

    return closest_value
```

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_01_closestvalue.ipynb) - notebook com o primeiro desafio.
-  [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/solution_01.ipynb) - notebook com a solu√ß√£o e testes.

---

### üìå Problema 2

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_02_kth_largest.ipynb) - notebook com o segundo desafio.

A fun√ß√£o `findKthLargestValue()` definida a seguir √© a fun√ß√£o respons√°vel por resolver o problema 2: 

```python
def findKthLargestValue(tree, k):
    """
    Finds the kth largest integer in a Binary Search Tree (BST).

    The function traverses the BST in an in-order manner to collect the node values in a sorted list.
    It then returns the kth largest value from this list. The BST is assumed to contain only integer values.
    In case of duplicate integers, they are treated as distinct values.
    The kth largest integer is determined in the context of these distinct values.

    Parameters:
    tree (BST): the Binary Search Tree (BST).
    k (int): A positive integer representing the kth position.

    Returns:
    int: The kth largest integer present in the BST.
    """
    vector = []
    index_aux = [k]

    search_element(vector, tree.root, index_aux)

    return vector[0]
```

**vamos entender melhor como a solu√ß√£o foi elaborada:**

Basicamente seguimos a seguinte l√≥gica:

- inicialmente declaramos duas listas que possuiram tamanho 1. O `vector` ser√° a lista que possuir√° o valor correspondente ao kesimo maior elemento da BST, j√° a lista `index_aux` ser√° a lista que conter√° o numero de n√≥s que deveremos passar at√© chegar no n√≥ correto:

```python
vector = []
index_aux = [k]
```

Em seguida chamamos a fun√ß√£o `search_element()` passando como argumentos o `vector`, o n√≥ raiz da bst (tree.root) e o `index_aux`.

```python
search_element(vector, tree.root, index_aux)
```

Vamos entender melhor como funciona essa fun√ß√£o `search_element()`:

```python
def search_element(vector, node, index_aux):
    """
        fun√ß√£o que obtem um vetor com o n√≥ desejado

        argumentos:
            - vector: vetor que armazenar√° o valor correto
            - node: n√≥ raiz da arvore
            - index_aux: vetor de auxilio para encontrar o valor correto

        retorno:
            - None
    """
    if index_aux[0] < 0:
        return
                   
    if node.right_child is not None:
        search_element(vector, node.right_child,index_aux)
    
    index_aux[0] = index_aux[0] - 1
    if index_aux[0] == 0:
        vector.append(node.value)
        return
    
    if node.left_child is not None:
        search_element(vector, node.left_child, index_aux)
```

Basicamente nessa fun√ß√£o recursiva, os primeiros elementos visitados s√£o os elementos da direita, que pela defini√ß√£o da **BST**, possui os maiores valores √† direita. a cada visita, a vari√°vel `index_aux[0]` √© decrementada, e ap√≥s isso, √© feita a verifica√ß√£o, onde se o valor de `index_aux[0]` for igual a zero, o valor do n√≥ atual dever√° ser adicionado no vetor `vector`. isso garante que o vetor seja preenchido apenas com um valor e com o valor correto. caso o `index_aux[0]` for menor que zero, √© retornado, j√° que n√£o ser√° mais preciso verificar os pr√≥ximos n√≥s.

- Por fim obtemos o valor resposta aplicando a seguinte express√£o na fun√ß√£o `findKthLargestValue()`:

```python
return vector[0]
```

## [3/5] üß™ Como executar os codigos e testes

Tanto o notebook referente ao problema 1 quanto o problema 2 possuem testes para garantir que as fun√ß√µes desenvolvidas funcionem adequadamente. 

**para rodar os testes diretamente do notebook:**

```bash
!pytest closestvalue.py -vv
```

**caso voc√™ queira rodar em seu ambiente de desenvolvimento**:

- crie o arquivo que conter√° os testes (lembrando que as fun√ß√µes de teste devem come√ßar com a palavra `test`);

- execute o comando:

```bash
$ pytest <nomedoarquivo>.py
```

## [4/5] ‚åõ An√°lise da complexidade dos problemas

### üìå Problema 1:
Ap√≥s analisar o funcionamento da fun√ß√£o encontrada para a solu√ß√£o do problema, percebemos que a complexidade da fun√ß√£o `findClosestValue()` depende do tamanho da √°rvore de busca bin√°ria e da profundidade do n√≥ mais pr√≥ximo ao valor alvo.

Em m√©dia, a complexidade de tempo √© O(log(N)), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre porque, em m√©dia, a busca em uma √°rvore de busca bin√°ria √© logar√≠tmica em rela√ß√£o ao n√∫mero de elementos na √°rvore. No entanto, no pior caso, a complexidade de tempo pode ser O(N), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre quando a √°rvore est√° desbalanceada e a busca percorre todos os n√≥s da √°rvore.

A complexidade de espa√ßo √© O(1), pois n√£o s√£o utilizadas estruturas de dados adicionais que dependem do tamanho da entrada.

- ü§î Dito isso, chegamos a um questionamento: quais s√£o as vantagens e desvantagens de resolver esse problema de forma iterativa em vez de recursivamente? 

Podemos responder esse questionamento analisando o funcionamento, e resumidamente, a abordagem iterativa oferece efici√™ncia de espa√ßo, controle direto sobre o fluxo de execu√ß√£o e evita o risco de estouro de pilha, mas pode ser mais complexa em alguns casos e menos expressiva em compara√ß√£o com a recursiva. 

---

### üìå Problema 2:

Dado que o problema 2 foi devidamente solucionado, uma quest√£o vem a cabe√ßa... ser√° que essa solu√ß√£o √© boa em termos de tempo de execu√ß√£o e mem√≥ria ü§î? vamos fazer um estudo melhor sobre essa solu√ß√£o.

**Complexidade de Tempo**:

Aplicando os conhecimetos adquiridos nos notebooks anteriores sobre [üìå U1T2 - Tempo de complexidade dos Algoritimos](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/u1t2.md) podemos definir a complexidade da fun√ß√£o `findKthLargestValue()` desta forma:

```python
def findKthLargestValue(tree, k):
    vector = []                                      # 1
    index_aux = [k]                                  # 1

    search_element(vector, tree.root, index_aux)     # O(?)

    return vector[0]                                 # 1
```

Observamos que a complexidade da fun√ß√£o `findKthLargestValue()` depende diretamente da complexidade da sua fun√ß√£o auxiliar `search_element()`. A complexidade de tempo da `search_element()` e influenciada pelo valor do par√¢metro `k`:

- **Melhor caso**: O melhor caso ser√° quando o valor do par√¢metro `k == 1`. Nessa situa√ß√£o a fun√ß√£o depender√° apenas da altura da **BST** (h).

- **Pior caso**: J√° no pior caso, seria quando o valor de `k == n`, sendo n o valor dos total de elementos da **BST**, ou seja, podemos afirmar que a complexidade depende do valor da vari√°vel `k`.

sendo assim, podemos afirmar que a complexidade da fun√ß√£o `search_element()` pode ser definida como `O(h + k)`e consequentemente podemos concluir tamb√©m que a complexidade da fun√ß√£o `findKthLargestValue()` se resume a `O(h + k)`.

J√° em rela√ß√£o de complexidade de mem√≥ria, precisamos de um vetor de tamanho 1, se fissermos vista grossa para isso, podemos concluir que o algoritmo `findKthLargestValue()` √© de `O(1)`

## [5/5] üé• Video Explicativo

- üé• [Link do video](https://youtu.be/xwxDhFiRqoA)
