# U1T3 - Desafio de Implementa√ß√£o

Atividade realizada por:
- **Aluno**: [Carlos Gabriel Medeiros da Silva](https://github.com/CarlosG18) **matricula**: 20230093859
- **Aluno**: [Jean Magnus Araujo de Souza Junior](https://github.com/JeanMagnus) **matricula**: 20240001171

## [1/5] ü§î Definindo os problemas

Os problemas resolvidos s√£o fornecidos pelo [repositorio do professor Ivanovitch](https://github.com/ivanovitchm/datastructure) referentes ao assunto da **semana 4**.


### üìå Problema 1

- **defini√ß√£o:** Dado um valor ( k ) e uma √°rvore de busca bin√°ria (BST) n√£o vazia com valores distintos, encontre o valor mais pr√≥ximo de ( k ) na BST.

- **exemplo:**
<center>
    <img width=300 src="https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/imgs/problema1.jpg"></img>
</center>

- **input**: k = 43 -> **output**: 45

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em sistemas de busca, como em um sistema de busca de produtos online. Por exemplo, um usu√°rio pode inserir um pre√ßo desejado e o sistema pode usar a √°rvore de busca bin√°ria para encontrar produtos com pre√ßos mais pr√≥ximos ao valor especificado pelo usu√°rio, mesmo que n√£o haja um produto com o pre√ßo exato. Isso pode melhorar a experi√™ncia do usu√°rio ao permitir que ele encontre produtos que atendam √†s suas necessidades, mesmo que n√£o tenham pre√ßos exatos correspondentes.

### üìå Problema 2

- **defini√ß√£o:** Dada uma √°rvore de busca bin√°ria (BST) n√£o vazia, retorne o ( k )¬∫ maior elemento da BST, onde ( k ) √© uma vari√°vel inteira fornecida.

- **exemplo:**
<center>
    <img width=300 src="https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/imgs/problema2.jpg"></img>
</center>

- **input**: k = 6 -> **output**: 28

- **aplica√ß√£o desse problema:** Esse problema pode ser √∫til em situa√ß√µes onde √© necess√°rio encontrar valores espec√≠ficos em uma cole√ß√£o ordenada, como em sistemas de an√°lise de dados para encontrar percentis espec√≠ficos em conjuntos de dados. Por exemplo, em um sistema de an√°lise de vendas, pode-se usar esse algoritmo para encontrar o produto que est√° no ( k )¬∫ lugar em termos de vendas, ajudando a identificar os produtos mais populares.

## [2/5] üí° Solu√ß√µes

### üìå Problema 1

Para a resolu√ß√£o desse problema, foi criado uma fun√ß√£o chamada `findClosestValue()`, que recebe uma √°rvore BST e um valor que deseja ser encontrado, ou um valor pr√≥ximo a ele, nessa √°rvore. Ent√£o para o desenvolvimento da fun√ß√£o, primeiramente foi criada uma vari√°vel que armazenar√° o valor atual mais pr√≥ximo do valor desejado, inicialmente nulo. Ent√£o, foi criada uma fun√ß√£o para atravessar a √°rvore, recursivamente, a fim de encontrar este valor desejado. Dessa forma, a fun√ß√£o analisa n√≥ por n√≥, se houver um valor mais pr√≥ximo que o valor almejado ele ser√° armazenado na variavel 'closest_value' declarada acima. Tudo isso √© analisado com base na propriedade da BST.

Segue abaixo a fun√ß√£o criada:

```python
def findClosestValue(tree, target):
    # Iniciando a vari√°vel como nula
    closest_value = None

    # Fun√ß√£o auxiliar para percorrer recursivamente
    def traverse(node):
        nonlocal closest_value

        # Caso base: se o n√≥ atual analisado for nulo, retorne a fun√ß√£o imediatamente
        if node is None:
            return

        # Atualiza o valor mais pr√≥ximo (na vari√°vel) caso seja necess√°rio
        if closest_value is None or abs(node.value - target) < abs(closest_value - target):
            closest_value = node.value

        # Continua a busca atravessando a √°rvore com base nas propriedades da BST
        if target < node.value:
            traverse(node.left_child)
        elif target > node.value:
            traverse(node.right_child)

    # Inicia a busca/travessia a partir do n√≥ raiz da √°rvore
    traverse(tree.root)

    return closest_value
```

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_01_closestvalue.ipynb) - notebook com o primeiro desafio.
-  [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/solution_01.ipynb) - notebook com a solu√ß√£o e testes.

### üìå Problema 2

explicar como foi feito a solu√ß√£o

- [![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T3/challenge_02_kth_largest.ipynb) - notebook com o segundo desafio.
- 

## [3/5] üß™ Como executar os codigos e testes

## [4/5] ‚åõ An√°lise da complexidade dos problemas

### üìå Problema 1:
Ap√≥s analisar o funcionamento da fun√ß√£o encontrada para a solu√ß√£o do problema, percebemos que a complexidade da fun√ß√£o `findClosestValue()` depende do tamanho da √°rvore de busca bin√°ria e da profundidade do n√≥ mais pr√≥ximo ao valor alvo.

Em m√©dia, a complexidade de tempo √© O(log(N)), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre porque, em m√©dia, a busca em uma √°rvore de busca bin√°ria √© logar√≠tmica em rela√ß√£o ao n√∫mero de elementos na √°rvore. No entanto, no pior caso, a complexidade de tempo pode ser O(N), onde N √© o n√∫mero de n√≥s na √°rvore. Isso ocorre quando a √°rvore est√° desbalanceada e a busca percorre todos os n√≥s da √°rvore.

A complexidade de espa√ßo √© O(1), pois n√£o s√£o utilizadas estruturas de dados adicionais que dependem do tamanho da entrada.

- ü§î Dito isso, chegamos a um questionamento: quais s√£o as vantagens e desvantagens de resolver esse problema de forma iterativa em vez de recursivamente? 

Podemos responder esse questionamento analisando o funcionamento, e resumidamente, a abordagem iterativa oferece efici√™ncia de espa√ßo, controle direto sobre o fluxo de execu√ß√£o e evita o risco de estouro de pilha, mas pode ser mais complexa em alguns casos e menos expressiva em compara√ß√£o com a recursiva. 



### üìå Problema 2:

## [5/5] üé• Video Explicativo

- üé• [Link do video](https://drive.google.com/file/d/14LrgX_7vX5yoe7F-W9U4S-vjGLZN6J7S/view?usp=sharing)
