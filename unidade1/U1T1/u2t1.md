# U1T1 - Desafio: usando estrutura de dados em √°rvore com uma aplica√ß√£o de Processamento de Linguagem Natural (PLN)

desafio realizado por:
- **Aluno**: [Carlos Gabriel Medeiros da Silva](https://github.com/CarlosG18) **matricula**: 20230093859
- **Aluno**: [Jean Magnus Araujo de Souza Junior](https://github.com/JeanMagnus) **matricula**: 20240001171

[![Jupyter](https://img.shields.io/badge/-Notebook-191A1B?style=flat-square&logo=jupyter)](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/resolution.ipynb) - notebook da aplica√ß√£o (com mais detalhes dos c√≥digos)

## Etapas do desafio

O objetivo do desafio √© criar um sistema de autocompletar palavras usando uma √°rvore AVL. O desafio foi dividido em algumas etapas para simplificar o processo. cada etapa ser√° brevemente discutida nas proximas se√ß√µes.

### [1/4] Pr√©-processamento do Corpus

Implementamos duas fun√ß√µes para obter os dados de um corpus e obter uma √∫nica string gigante. A `get_text_from_pdf()` que l√™ um pdf e obt√©m o texto desse pdf e temos a fun√ß√£o `get_from_text_csv()` que obt√©m o texto de uma coluna de uma determinada planilha em **.csv**. No decorrer do nosso sistema ultilizamos apenas a fun√ß√£o que obt√©m os dados de um **PDF**.

Para o tratamento do corpus, usamos a fun√ß√£o `clean_text()` que ultiliza alguns m√©todos da biblioteca `NLTK`:

```python
def clean_text(text, language):
  """
    fun√ß√£o que obt√©m um vetor com todas as palavras do texto.

      - par√¢metros:
        - text: string que possui o conteudo do texto.
        - language: idioma das palavras

      - retorno:
        - texto_tratado: a fun√ßao retorna uma lista com apenas palavras do texto passado como par√¢metro.
  """
  # retirando hifen em palavras que ocorreu por causa da limita√ß√£o do espa√ßo
  text = text.replace('-\n','')

  # obtendo apenas palavras minusculas e excluindo n√∫meros e caracteres especiais
  texto_tratado = regexp_tokenize(text.lower(), r'\b[A-Za-z]+\b', gaps=False)

  # obtendo todas as palavras de parada (stopwords)
  stopwords_ = set(stopwords.words(language))
  # obtendo todas as palavras que n√£o s√£o stopwords e que seu tamanho s√£o maiores que 2
  texto_tratado = [word for word in texto_tratado if word not in stopwords_ and len(word) > 2]

  #ajustando palavras com letras repetidas:
  for index,palavra in enumerate(texto_tratado):
    if tem_letra_repetida(palavra):
      texto_tratado[index] = remove_letras_repetidas(palavra)

  return set(texto_tratado)
```

Nessa Fun√ß√£o a string com todas as palavras √© transformado em uma lista com palavras. para realizar essa opera√ß√£o, aplicamos alguns tratamentos como:

    - Retiramos qualquer tipo de caracter especial, inclusive digitos e acentua√ß√£o;
    - Transformamos todas as palavras em minusculo;
    - Retiramos palavras de parada (stopwords);
    - Verificamos palavras que possuiam letras repetidas em sua composi√ß√£o;
    - Retiramos repeti√ß√£o de palavras ao retornar um `set()` do texto tratado.

### [2/4] Constru√ß√£o da √Årvore AVL

Com as palavras obtidas foi poss√≠vel criar uma **√Årvore AVL** fazendo a inser√ß√£o de todas elas na estrutura ultilizando um la√ßo simples que percorria todas as palavras e chamando o m√©todo `add()` da AVL.

### [3/4] Autocompletar

A fun√ß√£o de autocompletar foi desenvolvida da seguinte maneira:

- Foi verificado que caso o prefixo fosse menor que o valor dado pelo n√≥ atual a busca continuaria pelo n√≥ filho esquerdo e de forma semelhante, caso o prefixo fosse maior que o valor dado pelo n√≥ atual ele continuaria a busca pelo n√≥ filho direito;
- Foi verificado que caso o valor do n√≥ atual fosse igual ao prefixo, a busca deveria ocorrer tanto para o n√≥ filho esquerdo quanto o direito;
- Caso o valor do n√≥ fosse igual ao prefixo, o valor do n√≥ atual seria adicionado na lista;
- A condi√ß√£o de parada seria quando a busca atingisse um n√≥ folha, ou seja, um n√≥ que n√£o possuem filhos.

resumindo, o algoritimo iria percorrer um caminho ao qual possivelmente conteria as palavras indicadas e ao achar um n√≥ folha, voltaria fazendo a compara√ß√£o do prefixo com o valor do n√≥ atual, adicionando na lista e retornando essa lista a cada chamada. 

```python
def autocomplete(self,prefix):
      """
        fun√ß√£o que recebe um prefixo (parte inicial de uma palavra) e retorna
        uma lista com as poss√≠veis palavras completas encontradas na √°rvore.

            - par√¢metros:
                - prefix: prefixo de uma palavra

            - retorno:
                - ListOfWord: lista contendo todas as palavras que come√ßam com o prefixo informado
      """
      ListOfWord = set(self._search_prefix(prefix,self.root))

      return ListOfWord

    def _search_prefix(self, prefix, node):
      """
        fun√ß√£o recursiva para encontrar palavras que come√ßam com um determinado prefixo

            - par√¢metros:
                - prefix: prefixo ao qual as palavras da lista deveram ter
                - node: n√≥ que ser√° verificado a presen√ßa do prefixo

            - retorno:
                - Lista: uma lista de palavras que come√ßam com o prefixo
      """
      Lista = []
      if node is None:
        return

      # obtem o equivalente a string equivalente ao numero de caracteres do prefixo
      value_node = node.value[:len(prefix)]

      if prefix < value_node:
        if node.left_child is not None:
          Lista += self._search_prefix(prefix, node.left_child)
      elif prefix > value_node:
        if node.right_child is not None:
          Lista += self._search_prefix(prefix, node.right_child)
      else:
        if node.left_child is not None:
          Lista += self._search_prefix(prefix, node.left_child)
        if node.right_child is not None:
          Lista += self._search_prefix(prefix, node.right_child)
        Lista.append(node.value)

      return Lista
```

### [4/4] An√°lise de Desempenho

Foi realizado uma an√°lise no desempenho da **√°rvore AVL** em rela√ß√£o a uma **Lista** e uma **√°rvore de busca bin√°ria BST**. foram realizados algumas compara√ß√µes de tempo entre opera√ß√µes de inser√ß√£o, busca (atrav√©s da fun√ß√£o autocomplete). no final tamb√©m foi analisado se o tamanho do prefixo influ√™nciava no desempenho. 

#### Tempo de Inser√ß√£o

- AVL x LISTA

![AVL x LISTA](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/insercao_avl_list.png)

como podemos observar na imagem, a **AVL** possui um tempo bem maior de inser√ß√£o comparado com a lista, e isso se da pelo fato de que quando um valor √© adicionado na arvore AVL, ela precisa verificar se algum n√≥ est√° desbalanceado, caso esteja, ela realiza algumas opera√ß√µes (definidas como rota√ß√µes) para deixar sempre sua estrutura balanceada. e isso leva muito mais tempo do que apenas adicionar o valor no ultimo elemento do vetor, como ocorre na lista.


- AVL x BST

![AVL x BST](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/insercao_avl_bst.png)

analisando a imagem acima, algo semelhante ao caso anterior acontece, s√≥ que no caso do BST, os valores adicionados precisam passar por uma compara√ß√£o e numa lista isso n√£o acontece. por isso se compararmos os tempos desse grafico com o anterior o tempo de inser√ß√£o da BST ainda √© superior a uma lista por√©m inferior a uma AVL.

#### Tempo de Busca

Para realizar a compara√ß√£o de tempo de busca de uma lista e uma √°rvore AVL, foi nescess√°rio criar uma fun√ß√£o iterativa da fun√ß√£o autocomplete:

```python
def autocomplete(prefix, lista):
  listOfWords = []
  for palavra in lista:
    value_palavra = palavra[:len(prefix)]
    if prefix == value_palavra:
      listOfWords.append(palavra)

  return set(listOfWords)
```

Para auxiliar nos testes, criamos uma fun√ß√£o `criar_prefixos()` responsav√©l por criar uma lista de prefixos:

```python
def criar_prefixos(tam,qtd_letras):
  """
    fun√ß√£o que retorna uma lista de prefixos gerados aleatoriamente, seguindo a ordem: uma consoante, uma vogal.

    - par√¢metros:
        - tam: quantidade de prefixos que ser√£o gerados
        - qtd_letras: quantidade de letras que os prefixos ter√£o

    - retorno:
        - prefixos: retorna os prefixos criados
  """
  vogais = ['a','e','i','o','u']
  consoantes = ['q','r','t','y','p','s','d','f','g','h','j','l','c','b','n','m']
  prefixos = []
  for i in range(tam):
    prefix = ""
    for j in range(qtd_letras):
      if j % 2 == 0:
        prefix += random.choice(consoantes)
      else:
        prefix += random.choice(vogais)
    prefixos.append(prefix)

  return prefixos
```

- tempo de busca (autocomplete): AVL x LISTA

![AVL x LISTA](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/busca_avl_list.png)

podemos observar claramente a efici√™ncia da arvore AVL em compara√ß√£o com a lista. isso se d√° ao fato de que a lista precisa percorrer todos os elementos para encontrar as palavras corretas, portanto a complexidade √© de `O(n)`. j√° uma √°rvore AVL, por ter sua estrutura uma "divis√£o" ao qual os menores valores estariam do lado esquerdo do n√≥ raiz e os valores maiores do lado direito da raiz, a complexidade varia de acordo com a altura da arvore AVL, sendo `O(log(n))`, por isso a arvore se sai muito melhor em rela√ß√£o ao tempo na opera√ß√£o de busca em compara√ß√£o com uma lista.


- tempo de busca (autocomplete): AVL x BST

![AVL x BST](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/busca_avl_bst.png)

j√° nesse caso, n√£o √© t√£o conclusivo definir qual √© a melhor estrutura, pois o algoritmo se comporta de uma forma semelhante nas duas.

#### Tamanho do Prefixo

realizamos alguns testes com rela√ß√£o ao tamanho do prefixo.


- Prefixo pequeno

![prefixo pequeno](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/prefixo_pequeno.png)

podemos observar que em geral a AVL se sai melhor em rela√ß√£o a BST. E sobre esses picos no gr√°fico, podem est√° relacionados ao fato do sistema operacional atribuir alguns outros processos durante a execu√ß√£o do teste.


- Prefixo Grande

![prefixo grande](https://github.com/CarlosG18/aedii_dca0209/blob/main/unidade1/U1T2/imgs/prefixo_grande.png)

tamb√©m em casos onde o prefixo √© maior, podemos ver que a AVL se sai melhor. 

## Video Explicativo

- üé• [Link do video](https://youtu.be/1-R0XQM59VI)

## Frontend da Aplica√ß√£o

- [Link da aplica√ß√£o](https://autocomplete-u1t1.streamlit.app/)
